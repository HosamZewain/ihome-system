[
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "6b6fb8d6-3977-485a-a3ee-b792aedf0291",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC001-User Authentication Success",
    "description": "Verify that a user can login successfully with valid username and password and receive a valid JWT token with correct role information.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input valid username 'admin' and password 'admin123'\n        frame = context.pages[-1]\n        # Input valid username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input valid password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        # -> Click the Sign In button to submit login form\n        frame = context.pages[-1]\n        # Click the Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid username 'admin' and password 'admin123' into the respective fields\n        frame = context.pages[-1]\n        # Input valid username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input valid password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check for JWT token and user role information in local storage or session storage, or try to find user info in the UI or API responses\n        frame = context.pages[-1]\n        # Click on Users menu to check user details and roles\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[9]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Dashboard').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Users').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=System Admin').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=admin').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Admin').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363401956568//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.106Z",
    "modified": "2026-01-25T17:50:03.407Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "73f6a4af-8c0d-4eda-92bc-7941e2dacde9",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC002-User Authentication Failure with Invalid Credentials",
    "description": "Ensure login fails with appropriate error response when using invalid username or password.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input invalid username and password and submit login form\n        frame = context.pages[-1]\n        # Input invalid username\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidUser')\n        \n\n        frame = context.pages[-1]\n        # Input invalid password\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalidPass')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to submit login request\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Welcome Back').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign in to continue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Username').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Password').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sign In').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363402630315//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.112Z",
    "modified": "2026-01-25T17:50:04.166Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "069b0c24-9e64-4a5e-ad7a-c8d6a6b88ee8",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC003-JWT Token Enforcement and Role-Based Access Control",
    "description": "Verify that protected API endpoints reject requests without valid JWT tokens and enforce access permissions based on user role.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input admin username and password, then click Sign In button.\n        frame = context.pages[-1]\n        # Input admin username\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input admin password\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send request to a protected endpoint without JWT token to verify it rejects unauthorized access.\n        await page.goto('http://localhost:5173/api/protected-endpoint', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Send a request to a protected API endpoint without a JWT token to verify it rejects unauthorized access with 401 status.\n        await page.goto('http://localhost:5173/api/protected-endpoint', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Send a request to a protected API endpoint without a JWT token to verify it rejects unauthorized access with 401 status.\n        await page.goto('http://localhost:5173/api/protected-endpoint', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Login as a user with limited permissions to test access restrictions on admin-only endpoints.\n        frame = context.pages[-1]\n        # Click Logout button to logout admin user\n        elem = frame.locator('xpath=html/body/div/div/aside/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Login as a user with limited permissions to test access restrictions on admin-only endpoints.\n        frame = context.pages[-1]\n        # Input limited permission username\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('user_limited')\n        \n\n        frame = context.pages[-1]\n        # Input limited permission user password\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('userpass')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as limited permission user\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input limited permission user credentials and click Sign In.\n        frame = context.pages[-1]\n        # Input limited permission username\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('user_limited')\n        \n\n        frame = context.pages[-1]\n        # Input limited permission user password\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('userpass')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button to login as limited permission user\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted to Admin Endpoint').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Protected API endpoints did not reject unauthorized access or enforce access permissions correctly as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363420804961//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.118Z",
    "modified": "2026-01-25T17:50:22.265Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "41551c87-b5e4-49dc-bd51-ff19988a23d9",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC004-Product Creation with Mandatory Fields",
    "description": "Verify that a new product can be created successfully with required fields and optional fields, and returns correct HTTP status and product details.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Sign In button to login\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password and click Sign In button again\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking username field to focus, then send keys to input username 'admin', then input password 'admin123' similarly, then click Sign In button\n        frame = context.pages[-1]\n        # Click username input field to focus\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click password input field to focus\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Products menu to go to Products page\n        frame = context.pages[-1]\n        # Click on Products menu to navigate to Products page\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Add Product button to open product creation form\n        frame = context.pages[-1]\n        # Click Add Product button to open product creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down slightly to ensure 'Add Product' button is fully visible and not overlapped, then retry clicking 'Add Product' button\n        await page.mouse.wheel(0, 200)\n        \n\n        frame = context.pages[-1]\n        # Retry clicking 'Add Product' button to open product creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to click Unit dropdown (index 158) to open options, then click the option 'Pieces' from the dropdown list, then continue filling remaining fields and submit the form.\n        frame = context.pages[-1]\n        # Click Unit dropdown to open options\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr[72]/td[8]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Pieces' option from Unit dropdown\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr[82]/td[8]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Add Product' button to open product creation form again\n        frame = context.pages[-1]\n        # Click 'Add Product' button to open product creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill required fields: Product Name, SKU, Category, Selling Price; fill optional fields: Unit, Cost Price, Initial Stock Quantity, Description; then click Add Product button\n        frame = context.pages[-1]\n        # Input Product Name\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Product 002')\n        \n\n        frame = context.pages[-1]\n        # Input SKU\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TP002')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Product creation failed due to missing required fields').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The product creation test did not pass as expected. The test plan requires verifying successful product creation with HTTP status 201 and correct product details, but the test plan execution has failed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363423645205//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.125Z",
    "modified": "2026-01-25T17:50:25.148Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "f51c2fa6-35a9-45b6-bda7-4b13eddcb900",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC005-Product Update and Stock Adjustment",
    "description": "Verify updating a product's details including price, description, and quantity is successful and changes are reflected in subsequent fetch requests.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Retry clicking the Sign In button to log in.\n        frame = context.pages[-1]\n        # Retry clicking Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password 'admin123' again and click Sign In button to complete login.\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to focus/click on username field (index 2) before inputting text or try clearing and inputting username again.\n        frame = context.pages[-1]\n        # Click username input field to focus\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input username 'admin' after focusing username field\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        # -> Click the Sign In button (index 4) to log in.\n        frame = context.pages[-1]\n        # Click Sign In button to log in\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input password 'admin123' into password field (index 3) and click Sign In button (index 4) to log in.\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Products' tab to navigate to the product management page.\n        frame = context.pages[-1]\n        # Click on 'Products' tab to go to product management page\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Add Product' button to start creating a new product for testing.\n        frame = context.pages[-1]\n        # Click 'Add Product' button to create a new product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in product details: name, SKU, category, unit, selling price, cost price, initial stock quantity, and description, then submit the form.\n        frame = context.pages[-1]\n        # Input product name\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Product')\n        \n\n        frame = context.pages[-1]\n        # Input SKU\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TP-001')\n        \n\n        # -> Click 'Add Product' button again to reopen the product creation modal and retry filling product details with a valid category selection.\n        frame = context.pages[-1]\n        # Click 'Add Product' button to reopen product creation modal\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in product details: product name, SKU, select category 'Electronics', select unit 'Pieces', selling price, cost price, initial stock quantity, description, then submit the form.\n        frame = context.pages[-1]\n        # Input product name\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Product')\n        \n\n        frame = context.pages[-1]\n        # Input SKU\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TP-001')\n        \n\n        # -> Click Edit button for the newly created product 'Test Product' to update its details.\n        frame = context.pages[-1]\n        # Click Edit button for 'Test Product' to update details\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr[71]/td[8]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Update Failed: Product details not saved').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The product update process did not complete successfully as per the test plan. The updated product details including price, description, and quantity were not reflected in subsequent fetch requests.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362319210015//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.131Z",
    "modified": "2026-01-25T17:47:42.059Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "ec207ff9-ce59-43db-bcc8-2102d459bc08",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC006-Product Deletion and Data Removal",
    "description": "Verify that a product can be deleted successfully and subsequent requests for the product return 404 Not Found.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button to log in\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create a product for deletion\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password, then click Sign In button to log in\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Products' link in the navigation menu to navigate to the products management page\n        frame = context.pages[-1]\n        # Click on Products link in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Add Product' button to create a new product for deletion\n        frame = context.pages[-1]\n        # Click on Add Product button\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Add Product' button to open the product creation form\n        frame = context.pages[-1]\n        # Click on Add Product button\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the product details in the 'Add New Product' form and submit to create the product\n        frame = context.pages[-1]\n        # Input product name\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Product for Deletion')\n        \n\n        frame = context.pages[-1]\n        # Input SKU\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TPDEL-001')\n        \n\n        # -> Delete a product and verify deletion by checking for 404 on subsequent GET request\n        frame = context.pages[-1]\n        # Click Delete button for product 'ALEXA ECHO DOT' to delete it\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr[71]/td[8]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll to the product 'Test Product for Invoice' to ensure it is visible and then click its Delete button\n        frame = context.pages[-1]\n        # Click Delete button for 'Test Product for Invoice'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr/td[8]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Confirm button to finalize deletion of 'Test Product for Invoice'\n        frame = context.pages[-1]\n        # Click Confirm button to finalize product deletion\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr/td[8]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Test Product for Deletion').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363427585951//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.137Z",
    "modified": "2026-01-25T17:50:28.987Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "adc65c66-24bc-4cf3-9031-354719e5e2e8",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC007-Automatic Stock Increase on Purchase Invoice Creation",
    "description": "Verify that creating a purchase invoice increases product stock quantities accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try inputting password again or try alternative input method for password field.\n        frame = context.pages[-1]\n        # Retry input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Products page to record current stock quantity for a product.\n        frame = context.pages[-1]\n        # Click on Products in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Purchase Invoices page to create a new purchase invoice.\n        frame = context.pages[-1]\n        # Click on Purchase Invoices in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[4]/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try alternative navigation to Purchase Invoices page or scroll to reveal the link and click it.\n        await page.mouse.wheel(0, 300)\n        \n\n        frame = context.pages[-1]\n        # Click on Purchase Invoices in the navigation menu after scrolling\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[4]/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click + New Purchase button to start creating a new purchase invoice.\n        frame = context.pages[-1]\n        # Click + New Purchase button\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click + New Purchase button again to reopen the modal and verify presence of + Add Product button or try alternative ways to add product.\n        frame = context.pages[-1]\n        # Click + New Purchase button to reopen modal\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click + Add Product button to add product to the purchase invoice.\n        frame = context.pages[-1]\n        # Click + Add Product button\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select 'Test Product for Invoice' from product dropdown and input purchase quantity 5.\n        frame = context.pages[-1]\n        # Input purchase quantity 5\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/table/tbody/tr/td[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('5')\n        \n\n        # -> Click 'Create Purchase' button to submit the purchase invoice and verify creation.\n        frame = context.pages[-1]\n        # Click Create Purchase button to submit purchase invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr[18]/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Products page and fetch product details for 'Test Product for Invoice' to verify stock quantity increased by 5.\n        frame = context.pages[-1]\n        # Click on Products in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Test Product for Invoice').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=105 pcs').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362265565253//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.142Z",
    "modified": "2026-01-25T17:47:42.075Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "0df0ebcc-0c52-4703-beee-12333a15e81b",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC008-Purchase Invoice Deletion with Stock Adjustment",
    "description": "Verify purchase invoice deletion does not remove stock back (if business logic permits) or handles stock rollback correctly if defined.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password using correct input indexes, then click Sign In button\n        frame = context.pages[-1]\n        # Input the username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        # -> Input password and click Sign In button\n        frame = context.pages[-1]\n        # Input the password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Purchase Invoices' to navigate to the purchase invoices page\n        frame = context.pages[-1]\n        # Click on 'Purchase Invoices' in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[4]/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click '+ New Purchase' button at index 14 to create a new purchase invoice\n        frame = context.pages[-1]\n        # Click '+ New Purchase' button to create a new purchase invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a supplier from dropdown to proceed with purchase invoice creation\n        frame = context.pages[-1]\n        # Click supplier dropdown to select a supplier\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a supplier from the dropdown list to proceed with purchase invoice creation\n        frame = context.pages[-1]\n        # Select supplier ' ' from dropdown\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the delete button for the newly created purchase invoice to delete it\n        frame = context.pages[-1]\n        # Click Delete Purchase button for the first purchase invoice in the list\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr/td[7]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Products' tab in the navigation menu to navigate to the Products page\n        frame = context.pages[-1]\n        # Click on 'Products' tab in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Loading iHome System...').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363430909652//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.148Z",
    "modified": "2026-01-25T17:50:32.435Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "1493fc1c-8c51-445a-9c64-3d5cda070914",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC009-Sales Invoice Creation and Association with Products",
    "description": "Verify sales invoice can be created with multiple line items and the invoice details reflect all products and quantities correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the Sign In button to attempt login\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Re-input username and password correctly and click Sign In button again\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Invoices' tab to start creating a new sales invoice.\n        frame = context.pages[-1]\n        # Click on the 'Invoices' tab in the sidebar to navigate to sales invoices page\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[5]/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'New Invoice' button to start creating a new sales invoice.\n        frame = context.pages[-1]\n        # Click the 'New Invoice' button to open the invoice creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input quantity for the first product line item using the correct input element index, then add the line item.\n        frame = context.pages[-1]\n        # Input quantity 2 for first product line item\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/div[4]/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2')\n        \n\n        frame = context.pages[-1]\n        # Input discount 0 for first product line item\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add first product line item\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input customer name and phone number, add two different products with quantities and discounts, add them as line items, then save the invoice.\n        frame = context.pages[-1]\n        # Input customer name as 'Test Customer'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Customer')\n        \n\n        frame = context.pages[-1]\n        # Input phone number for customer\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        frame = context.pages[-1]\n        # Input quantity 2 for first product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('2')\n        \n\n        frame = context.pages[-1]\n        # Input discount 0 for first product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add first product line item\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select second product, input quantity and discount, add second line item, then save the invoice and verify details.\n        frame = context.pages[-1]\n        # Input quantity 1 for second product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1')\n        \n\n        frame = context.pages[-1]\n        # Input discount 0 for second product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('0')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add second product line item\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Create Invoice' button to save the invoice and verify the response and invoice details.\n        frame = context.pages[-1]\n        # Click the 'Create Invoice' button to save the invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invoice Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Sales invoice creation with multiple line items did not complete successfully as expected according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362264905541//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.153Z",
    "modified": "2026-01-25T17:47:42.090Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "2ea36d1b-ca0c-40f5-b1e5-0d26e69f7bb6",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC010-Sales Invoice Deletion and Stock Verification",
    "description": "Verify deleting a sales invoice removes the record and appropriately does not affect stock levels negatively.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click Sign In button to log in\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input username and password, then click Sign In button to log in\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Invoices' link in the left menu to go to the sales invoices page\n        frame = context.pages[-1]\n        # Click on 'Invoices' link in the left menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[5]/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to scroll to 'Invoices' link and click again or find alternative navigation to sales invoices\n        await page.mouse.wheel(0, 200)\n        \n\n        frame = context.pages[-1]\n        # Click on 'Invoices' link in the left menu after scrolling\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[5]/div/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'New Invoice' button to create a new sales invoice for testing\n        frame = context.pages[-1]\n        # Click 'New Invoice' button to create a new sales invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input customer name, select product, set quantity, and add item to invoice\n        frame = context.pages[-1]\n        # Input customer name for new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Customer')\n        \n\n        frame = context.pages[-1]\n        # Open product dropdown to select product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Add' button to add product to invoice items, then click 'Create Invoice' to save the invoice\n        frame = context.pages[-1]\n        # Click 'Add' button to add product to invoice items\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Create Invoice' button to save the new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Create Invoice' button to save the new invoice\n        frame = context.pages[-1]\n        # Click 'Create Invoice' button to save the new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input customer name, select product, set quantity, add item to invoice, and create invoice\n        frame = context.pages[-1]\n        # Input customer name for new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Customer')\n        \n\n        frame = context.pages[-1]\n        # Open product dropdown to select product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Set quantity to 1 for the product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add product to invoice items\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Create Invoice button to save the new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Create Invoice' button to save the new invoice\n        frame = context.pages[-1]\n        # Click 'Create Invoice' button to save the new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input customer name, select product, set quantity, add item to invoice, and create invoice\n        frame = context.pages[-1]\n        # Input customer name for new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Customer')\n        \n\n        frame = context.pages[-1]\n        # Open product dropdown to select product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select first product from dropdown\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Set quantity to 1 for the product\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1')\n        \n\n        frame = context.pages[-1]\n        # Click Add button to add product to invoice items\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div/div[2]/div[2]/div/div[5]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Create Invoice button to save the new invoice\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Invoice deletion successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The sales invoice deletion did not complete as expected. The invoice record was not removed or stock levels may have been affected negatively.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362265295757//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.159Z",
    "modified": "2026-01-25T17:47:42.098Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "6e9fa5e6-de3c-4636-b024-c918ed6ca797",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC011-Customer Management - Create, Update, View, and Delete",
    "description": "Verify that customers can be created, updated, fetched (including purchase history), and deleted correctly with appropriate HTTP status codes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password and click Sign In button to log in\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Customers tab to start creating a new customer\n        frame = context.pages[-1]\n        # Click on Customers tab\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on '+ Add Customer' button to open the new customer creation form\n        frame = context.pages[-1]\n        # Click on + Add Customer button\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the new customer details and submit the form to create the customer\n        frame = context.pages[-1]\n        # Input Full Name as Test User\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input Email as testuser@example.com\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input Phone as 1234567890\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        frame = context.pages[-1]\n        # Input Address as 123 Test Address, Test City\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123 Test Address, Test City')\n        \n\n        frame = context.pages[-1]\n        # Click Add Customer button to submit the form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Edit button for 'Test User' to update customer details\n        frame = context.pages[-1]\n        # Click Edit button for Test User\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr[3]/td[6]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Update the email field and submit the form to update the customer\n        frame = context.pages[-1]\n        # Update Email to updateduser@example.com\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('updateduser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Update Customer button to submit changes\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[4]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Edit button for 'Test User' to fetch detailed customer info including purchase history\n        frame = context.pages[-1]\n        # Click Edit button for Test User to fetch details\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr[3]/td[6]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Customer Creation Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Customer creation, update, fetch (including purchase history), and deletion did not complete successfully with expected HTTP status codes.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362264566235//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.165Z",
    "modified": "2026-01-25T17:47:42.146Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "54622061-1975-43d0-bfc6-91a8307a37a7",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC012-Supplier Management CRUD Operations",
    "description": "Verify full CRUD functionality for suppliers including creation, update, retrieval, and deletion with correct status codes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button to log in.\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        # -> Retry login by inputting username and password again and clicking Sign In.\n        frame = context.pages[-1]\n        # Re-input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Re-input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button again\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Suppliers' tab to navigate to the suppliers management page.\n        frame = context.pages[-1]\n        # Click on Suppliers tab\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[4]/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click '+ Add Supplier' button to open the supplier creation form.\n        frame = context.pages[-1]\n        # Click '+ Add Supplier' button\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in supplier name, email, phone, and address fields, then click 'Add Supplier' button to create new supplier.\n        frame = context.pages[-1]\n        # Input supplier name\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Supplier')\n        \n\n        frame = context.pages[-1]\n        # Input supplier email\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('test@supplier.com')\n        \n\n        frame = context.pages[-1]\n        # Input supplier phone\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        frame = context.pages[-1]\n        # Input supplier address\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[3]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('123 Test Address, Test City')\n        \n\n        frame = context.pages[-1]\n        # Click 'Add Supplier' button to submit form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Edit Supplier' button for 'Test Supplier' to open the update form.\n        frame = context.pages[-1]\n        # Click 'Edit Supplier' button for 'Test Supplier'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr[5]/td[4]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Update the phone number field and click 'Update Supplier' button to save changes.\n        frame = context.pages[-1]\n        # Update phone number to '1234567890'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('1234567890')\n        \n\n        frame = context.pages[-1]\n        # Click 'Update Supplier' button to save changes\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Delete Supplier' button for 'Test Supplier' to delete the supplier.\n        frame = context.pages[-1]\n        # Click 'Delete Supplier' button for 'Test Supplier'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr[5]/td[4]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Supplier creation successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Full CRUD functionality for suppliers did not complete successfully as expected. The test plan execution failed to verify creation, update, retrieval, and deletion with correct status codes.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362264821242//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.170Z",
    "modified": "2026-01-25T17:47:42.154Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "bc20648a-dc2e-436f-833a-add2ab780c9d",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC013-Expense Management with Category Operations",
    "description": "Verify that expenses and expense categories can be independently created, updated, retrieved, and deleted correctly maintaining data integrity.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the Sign In button to log in\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click username input and re-enter username and password, then click Sign In button again\n        frame = context.pages[-1]\n        # Re-input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Re-input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Expenses tab to manage expenses and categories\n        frame = context.pages[-1]\n        # Click on Expenses tab\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[6]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create new expense category\n        frame = context.pages[-1]\n        # Click Add Expense button to create a new expense\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Create new expense category by locating category management UI or adding a new category\n        frame = context.pages[-1]\n        # Click on category dropdown to check for option to add new category\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Expense Category Successfully Created').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution for verifying independent creation, update, retrieval, and deletion of expenses and expense categories has failed. Expected success messages or status codes were not observed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363470001039//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.176Z",
    "modified": "2026-01-25T17:51:11.496Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "c2392aa3-515f-4f42-9085-4f2f325135f0",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC014-User Management CRUD with Role Assignment",
    "description": "Verify users can be created, updated with role assignments, fetched, and deleted properly with correct status codes and data integrity.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button to authenticate\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Users' tab under Admin section to manage users\n        frame = context.pages[-1]\n        # Click on 'Users' tab under Admin section\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[9]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'New User' button to open user creation form\n        frame = context.pages[-1]\n        # Click 'New User' button to create a new user\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill Full Name, Username, Password, select Role, and click Save User button\n        frame = context.pages[-1]\n        # Input Full Name as 'Test User'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Input Username as 'testuser'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser')\n        \n\n        frame = context.pages[-1]\n        # Input Password as 'TestPass123!'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPass123!')\n        \n\n        frame = context.pages[-1]\n        # Click Save User button to create user\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Edit' button for 'Test User' to update user details and role\n        frame = context.pages[-1]\n        # Click 'Edit' button for 'Test User'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr[2]/td[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Change the role to a different one (if available), update Full Name, leave password blank, and save the user\n        frame = context.pages[-1]\n        # Update Full Name to 'Test User Updated'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User Updated')\n        \n\n        frame = context.pages[-1]\n        # Leave Password blank to keep current password\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Click Save User button to save updates\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[5]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Delete' button for 'Test User Updated' to delete the user\n        frame = context.pages[-1]\n        # Click 'Delete' button for 'Test User Updated'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr[2]/td[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try refreshing the page to reload the user list and then attempt to delete the user again\n        frame = context.pages[-1]\n        # Click 'Users' tab to refresh the users list page\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[9]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Try clicking 'Delete' button for 'Test User Updated' again after refresh\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr[2]/td[4]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=User creation and update successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: User creation, update, fetch, and deletion did not complete successfully with correct status codes and data integrity.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363476341383//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.183Z",
    "modified": "2026-01-25T17:51:17.798Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "c4a3b442-af4b-4b2b-95be-ca58cec68913",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC015-Roles & Permissions Management",
    "description": "Verify roles can be created with assigned permissions, updated, deleted, and permissions listings can be fetched correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button to log in.\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Roles' link in the Admin section to proceed with permissions and roles testing.\n        frame = context.pages[-1]\n        # Click on 'Roles' link in the Admin section\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[10]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'New Role' button to open the role creation form and fetch permissions list.\n        frame = context.pages[-1]\n        # Click 'New Role' button to open role creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'New Role' button to open the role creation form and then input role details and select permissions.\n        frame = context.pages[-1]\n        # Click 'New Role' button to open role creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input 'Test Role' into Role Name field (index 3), input description into Description field (index 4), select permissions at indexes 7, 13, 16, then click 'Save Role' button (index 20).\n        frame = context.pages[-1]\n        # Input role name 'Test Role'\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Role')\n        \n\n        frame = context.pages[-1]\n        # Input role description\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Role for testing permissions assignment')\n        \n\n        frame = context.pages[-1]\n        # Select 'Add Products' permission checkbox\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[2]/div/label[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select 'Edit Customers' permission checkbox\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[3]/div/label[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select 'Create Invoice/Quote' permission checkbox\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[4]/div/label[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Edit' button for the 'Test Role' to update its permissions.\n        frame = context.pages[-1]\n        # Click 'Edit' button for the 'Test Role' to update permissions\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr/td[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Toggle some permissions checkboxes to update the role's permissions, then click 'Save Role' button to save changes.\n        frame = context.pages[-1]\n        # Toggle 'Add Products' permission checkbox\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[2]/div/label[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Toggle 'Edit Customers' permission checkbox\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[3]/div/label[4]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Toggle 'Create Invoice/Quote' permission checkbox\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[2]/div[4]/div/label[3]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click 'Save Role' button to save updated role permissions\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/div/form/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Delete the 'Test Role' from the Roles & Permissions list.\n        frame = context.pages[-1]\n        # Click 'Edit' button for the 'Test Role' to open edit form\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[2]/table/tbody/tr/td[4]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Refresh the Roles & Permissions page to verify if 'Test Role' exists, then proceed accordingly.\n        await page.goto('http://localhost:5173/admin/roles', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Roles & Permissions').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=New Role').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Admin').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Full System Access').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3 permissions').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Edit').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363483001573//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.189Z",
    "modified": "2026-01-25T17:51:24.514Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "45d4342c-ead6-4eb3-a76a-4f427b52590d",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC016-Dashboard Analytics Data Accuracy",
    "description": "Verify the dashboard displays accurate and up-to-date charts and metrics reflecting current products, sales, purchases, expenses, and other key business data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button to login as authorized user\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Welcome back! Here\\'s your business overview.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Total Revenue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=EGP 452,262.00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Total Expenses').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=EGP 3,000.00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Net Profit').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=EGP 449,262.00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Stock Value').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=EGP 271,445.39').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=84').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Products').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Low Stock').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=31').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pending').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=81').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Paid').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Mon').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Wed').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Thu').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Fri').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sat').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Sun').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Lezn i13Fac...').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=MASTERContr...').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=DUALR3LITE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Lezn R7 CAT...').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Smart DoorL...').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=INVOICE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ACC-SINV-2025-00050 - Hamada Elshazly').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ACC-SINV-2025-00056 - .  ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ACC-SINV-2025-00007 -   ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ACC-SINV-2025-00039 - .  ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ACC-SINV-2025-00033 - .  ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=EXPENSE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Rent - $3000.00').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363486791451//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.195Z",
    "modified": "2026-01-25T17:51:28.410Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "5e430ad1-652d-40d6-a91f-50329ed60d01",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC017-API Error Handling for Non-Existent Resources",
    "description": "Verify that API endpoints return appropriate 404 Not Found status when querying or manipulating non-existent products, customers, invoices, or other entities.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password and click Sign In button\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send GET request to product with invalid ID and verify 404 response\n        await page.goto('http://localhost:5173/api/products/invalid-id', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Check if there is an API testing or developer tool in the UI or use navigation to Products to see if we can test invalid product ID GET request\n        frame = context.pages[-1]\n        # Click on Products to check for product details or API testing options\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Customers page to check for similar UI and possible API testing options or to prepare for API tests\n        frame = context.pages[-1]\n        # Click on Customers to check for customer details or API testing options\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[4]/div/ul/li/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=NonExistentEntityError').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: API endpoints did not return 404 Not Found status for non-existent products, customers, or invoices as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362264598112//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.200Z",
    "modified": "2026-01-25T17:47:42.262Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "704c79c3-136d-47f6-a925-c8732222efd4",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC018-Sensitive Operations Require Proper Permissions",
    "description": "Verify that deleting records such as products, invoices, users, roles, and expense categories require proper permissions and confirmation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password and click Sign In to log in as admin\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Navigate to Products page to test delete permission and confirmation for products\n        frame = context.pages[-1]\n        # Click Products link to go to Products page\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Attempt to delete a product as user without delete permission\n        frame = context.pages[-1]\n        # Click Delete button for first product to test delete permission without permission\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr/td[8]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Log out admin and log in as user without delete permission to test delete action on products and expect 403 Forbidden response\n        frame = context.pages[-1]\n        # Click Logout button to log out admin\n        elem = frame.locator('xpath=html/body/div/div/aside/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Delete Successful').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Deleting records such as products requires proper permissions and confirmation. The test plan execution failed because the expected deletion success message was not found, indicating the deletion did not proceed as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to re-run the test",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769363501212354//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.206Z",
    "modified": "2026-01-25T17:51:42.689Z"
  },
  {
    "projectId": "593cb2b6-ecbf-4b23-ad03-f680609a6943",
    "testId": "1c1e725a-3643-40ce-9ee3-12b8a967c10f",
    "userId": "c4787448-10c1-7006-2ef6-2ede28edd700",
    "title": "TC019-Stock Update via Stock-Specific API Endpoint",
    "description": "Verify that product stock quantities can be updated independently using the dedicated stock update endpoint and reflect accurate changes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click Sign In button.\n        frame = context.pages[-1]\n        # Input username admin\n        elem = frame.locator('xpath=html/body/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password admin123\n        elem = frame.locator('xpath=html/body/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click Sign In button\n        elem = frame.locator('xpath=html/body/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Products link in the navigation menu to view product list.\n        frame = context.pages[-1]\n        # Click on Products link in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send PATCH request to /api/products/TPINV-001/stock with updated quantity.\n        await page.goto('http://localhost:5173/api/products/TPINV-001/stock', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Send a proper PATCH request to /api/products/TPINV-001/stock with updated quantity using API testing method or UI if available.\n        await page.goto('http://localhost:5173/products', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Send PATCH request to /api/products/TPINV-001/stock with updated quantity 150 and verify response and product stock update.\n        await page.goto('http://localhost:5173/api/products/TPINV-001/stock', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on Products link to view product list and select a product to record current stock.\n        frame = context.pages[-1]\n        # Click on Products link in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click Edit button for 'Test Product for Invoice' to update stock quantity via UI or prepare for API PATCH request.\n        frame = context.pages[-1]\n        # Click Edit button for 'Test Product for Invoice' to update stock quantity\n        elem = frame.locator('xpath=html/body/div/div/main/div/div[3]/table/tbody/tr/td[8]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send PATCH request to /api/products/TPINV-001/stock with updated stock quantity 150 and verify response and product stock update.\n        await page.goto('http://localhost:5173/api/products/TPINV-001/stock', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on Products link to view product list and select a product to update stock quantity.\n        frame = context.pages[-1]\n        # Click on Products link in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Send PATCH request to /api/products/TPINV-001/stock with updated quantity 150 and verify response and product stock update.\n        await page.goto('http://localhost:5173/api/products/TPINV-001/stock', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on Products link to view product list and select a product to update stock quantity.\n        frame = context.pages[-1]\n        # Click on Products link in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Stock update successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan execution failed: Product stock quantities could not be updated independently using the dedicated stock update endpoint, or the changes did not reflect accurately.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/c4787448-10c1-7006-2ef6-2ede28edd700/1769362265739854//tmp/test_task/result.webm",
    "created": "2026-01-25T12:25:32.211Z",
    "modified": "2026-01-25T17:47:42.276Z"
  }
]
